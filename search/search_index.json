{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Note The project is long done, but publishing it is a work in progress. Some links in this documentation might be dead. MLS800 \u00b6 The MLS800 is an open-source 1U rack unit MIDI controlled Loop Switcher with 8 audio loops. Features \u00b6 8 independent audio loops 128 presets Active preset is remotely controlled through Program Change MIDI messages Easy to read through a 4 digits 7 segments display and 9 illuminated switches Open source Sources \u00b6 The project is built around three repositories : blemasle/mls800-pcb : Motherboard and daughterboard PCBs blemasle/mls800-firmware : Firmware that needs to be loaded onto the motherboard blemasle/mls800-enclosure : CAD files needed to produce the enclosure","title":"Home"},{"location":"#mls800","text":"The MLS800 is an open-source 1U rack unit MIDI controlled Loop Switcher with 8 audio loops.","title":"MLS800"},{"location":"#features","text":"8 independent audio loops 128 presets Active preset is remotely controlled through Program Change MIDI messages Easy to read through a 4 digits 7 segments display and 9 illuminated switches Open source","title":"Features"},{"location":"#sources","text":"The project is built around three repositories : blemasle/mls800-pcb : Motherboard and daughterboard PCBs blemasle/mls800-firmware : Firmware that needs to be loaded onto the motherboard blemasle/mls800-enclosure : CAD files needed to produce the enclosure","title":"Sources"},{"location":"building/","text":"Building instructions \u00b6 The project is built around three repositories : blemasle/mls800-pcb : Motherboard and daughterboard PCBs blemasle/mls800-firmware : Firmware that needs to be loaded onto the motherboard blemasle/mls800-enclosure : CAD files needed to produce the enclosure While the PCB and firmware are mandatory, you can totally omit to build the enclosure - which is the most expensive part of the build. Important considerations \u00b6 Disclaimer The present project was a personal study case to see I close I could come to a \u201cprofessional\u201d product. I knew almost nothing at the time and had to learn everything. As a consequence, and while I did my best, the finished result is not flawless. Before you really consider this\u2026 I\u2019ve built this rack several years ago, and have been using it since then. However, I do not have physical access to the rack at the moment. I used some time off to publish this work, and in order to do so, I had to change some parts of the code. The 4 years old one I\u2019m using didn\u2019t build anymore. I\u2019m unable to test these changes at the moment, so please reach to me first if you really considering building the rack! Ordering the PCB \u00b6 Download the latest release . You\u2019ll find inside the Gerber files that can be used by the manufacturer of your choice. Just be aware that the PCB is uncommonly large (around 30cm) and that some manufacturers might refuse it. Seeed and OSHPark are good choices. I personally used Seeed because I needed several iterations before settling on a layout and OSHPark was too expensive for that. As of right now (January 2019), OSHPark charge around 183$ for 3 top notch, gold plated PCBs, while Seeed charge around 50$ for 5. I also still have some leftovers from the last batch \ud83d\ude09 Soldering the PCB \u00b6 If you know how to solder SMD components, the PCB presents no difficulties whatsoever. If you don\u2019t, check out this excellent Dave\u2019s EEVBlog tutorial . There are a lot of identical components in those two PCBs so it can feel a bit tedious after some time. Also, don\u2019t be greedy on the tin on the back connectors as solder joints are responsible for keeping your connector in place while inserting or removing plugs. If you decide to build the enclosure some of that pressure will be relieved through back screws but this is just an extra layer of strengthening, you should not rely on it. Flashing the firmware on a blank board \u00b6 After soldering the PCB, you\u2019ll need to flash the necessary bits to its processor to bring it to life. To do so, burn the Arduino micro bootloader through the standard ICSP port P1 , the \u25b6 indicating the pin 1 . You\u2019ll need either a programmer or another Arduino with the ArduinoISP sketch loaded on to it. I usually dedicate an Arduino Nano to this task. A complete procedure can be found on the Arduino website . Upload the ArduinoISP sketch to a second Arduino Carefully wire your programmer to the MLS800 PCB From the Arduino IDE, select the Arduino micro board and Arduino as ISP programmer Select the COM port of your programmer Hit Burn Bootloader command Once done, the Edit LED should blink. Next, follow Flashing the firmware instructions. Ordering the case and display bezel \u00b6 All the files required to order the enclosure can be downloaded over the github repository . As I said earlier, I choose Protocase - which I again highly recommend - to produce the case parts. The front panel bezel has been ordered from Bay Plastics Ltd , but I guess Protocase would be able to make it. All required information are included in the release files. Nevertheless, and because the only way to release files with Solidworks seems to create a flat directory structure, here is you need a sum up : Part Description Thickness Material / Technic Color Manufacturer Rack-Chassis Rack case bottom 0.048\u201d Cold rolled steel Matte Black Protocase Rack-Cover Rack case top 0.048\u201d Cold rolled steel Matte Black Protocase Rack-FrontPanel Rack case front 0.060\u201d Cold rolled steel Matte Black Protocase MountingBracket Daughterboard mounting bracket 0.048\u201d Cold rolled steel Matte Black Protocase mls800 REV 3 - GRAPHICS - v2.svg Front and Back illustrations \u274c Digital printing White Protocase FrontPanel-Bezel Main display bezel 0.118\u201d/3mm Acrylic(Perspex) 4401 Red Bay Plastics Ltd Assembly \u00b6 Warning While I knew nothing about tolerances at the time and did not take those into account during my designs, I only had to remove one screw and not fully tighten another for the case to be perfectly aligned. Both problematic screws where on the front panel \u201cS\u201d mounting bracket, which I knew would be a very tight fit without using tolerances. Now that you have all the pieces at hand, let\u2019s play some Lego\u00ae \ud83d\ude04! First, screw the motherboard to the Rack chassis, then the daughterboard to the mounting bracket. Do not forget to add rear screws to the stacked jack headers to relieve the pressure on the solder joints while inserting or removing jacks. Note Please note that I decided to remove the bottom middle screw of the daughter board to avoid inducing tension to the PCB. You can now place the mounting bracket on to the rack chassis, and connect the ribbon cable between the two PCBs. Then, snap the bezel into the front panel. This should be a precise fit and should not require any rework and/or glue to make it stick. Screw the front panel and the cover together. Finally, screw together the two subassemblies. You\u2019re done! Note On my unit, the top right screw of the mounting bracket is not fully tightened. When it is, some of the switches do not properly work. It comes from the fact that the rack was designed without any tolerances consideration. Knowing that, I consider it a miracle that I only have 2 minor flaws on the final product. That underlines once more Protocase\u2019s wonderful work.","title":"Building instructions"},{"location":"building/#building-instructions","text":"The project is built around three repositories : blemasle/mls800-pcb : Motherboard and daughterboard PCBs blemasle/mls800-firmware : Firmware that needs to be loaded onto the motherboard blemasle/mls800-enclosure : CAD files needed to produce the enclosure While the PCB and firmware are mandatory, you can totally omit to build the enclosure - which is the most expensive part of the build.","title":"Building instructions"},{"location":"building/#important-considerations","text":"Disclaimer The present project was a personal study case to see I close I could come to a \u201cprofessional\u201d product. I knew almost nothing at the time and had to learn everything. As a consequence, and while I did my best, the finished result is not flawless. Before you really consider this\u2026 I\u2019ve built this rack several years ago, and have been using it since then. However, I do not have physical access to the rack at the moment. I used some time off to publish this work, and in order to do so, I had to change some parts of the code. The 4 years old one I\u2019m using didn\u2019t build anymore. I\u2019m unable to test these changes at the moment, so please reach to me first if you really considering building the rack!","title":"Important considerations"},{"location":"building/#ordering-the-pcb","text":"Download the latest release . You\u2019ll find inside the Gerber files that can be used by the manufacturer of your choice. Just be aware that the PCB is uncommonly large (around 30cm) and that some manufacturers might refuse it. Seeed and OSHPark are good choices. I personally used Seeed because I needed several iterations before settling on a layout and OSHPark was too expensive for that. As of right now (January 2019), OSHPark charge around 183$ for 3 top notch, gold plated PCBs, while Seeed charge around 50$ for 5. I also still have some leftovers from the last batch \ud83d\ude09","title":"Ordering the PCB"},{"location":"building/#soldering-the-pcb","text":"If you know how to solder SMD components, the PCB presents no difficulties whatsoever. If you don\u2019t, check out this excellent Dave\u2019s EEVBlog tutorial . There are a lot of identical components in those two PCBs so it can feel a bit tedious after some time. Also, don\u2019t be greedy on the tin on the back connectors as solder joints are responsible for keeping your connector in place while inserting or removing plugs. If you decide to build the enclosure some of that pressure will be relieved through back screws but this is just an extra layer of strengthening, you should not rely on it.","title":"Soldering the PCB"},{"location":"building/#flashing-the-firmware-on-a-blank-board","text":"After soldering the PCB, you\u2019ll need to flash the necessary bits to its processor to bring it to life. To do so, burn the Arduino micro bootloader through the standard ICSP port P1 , the \u25b6 indicating the pin 1 . You\u2019ll need either a programmer or another Arduino with the ArduinoISP sketch loaded on to it. I usually dedicate an Arduino Nano to this task. A complete procedure can be found on the Arduino website . Upload the ArduinoISP sketch to a second Arduino Carefully wire your programmer to the MLS800 PCB From the Arduino IDE, select the Arduino micro board and Arduino as ISP programmer Select the COM port of your programmer Hit Burn Bootloader command Once done, the Edit LED should blink. Next, follow Flashing the firmware instructions.","title":"Flashing the firmware on a blank board"},{"location":"building/#ordering-the-case-and-display-bezel","text":"All the files required to order the enclosure can be downloaded over the github repository . As I said earlier, I choose Protocase - which I again highly recommend - to produce the case parts. The front panel bezel has been ordered from Bay Plastics Ltd , but I guess Protocase would be able to make it. All required information are included in the release files. Nevertheless, and because the only way to release files with Solidworks seems to create a flat directory structure, here is you need a sum up : Part Description Thickness Material / Technic Color Manufacturer Rack-Chassis Rack case bottom 0.048\u201d Cold rolled steel Matte Black Protocase Rack-Cover Rack case top 0.048\u201d Cold rolled steel Matte Black Protocase Rack-FrontPanel Rack case front 0.060\u201d Cold rolled steel Matte Black Protocase MountingBracket Daughterboard mounting bracket 0.048\u201d Cold rolled steel Matte Black Protocase mls800 REV 3 - GRAPHICS - v2.svg Front and Back illustrations \u274c Digital printing White Protocase FrontPanel-Bezel Main display bezel 0.118\u201d/3mm Acrylic(Perspex) 4401 Red Bay Plastics Ltd","title":"Ordering the case and display bezel"},{"location":"building/#assembly","text":"Warning While I knew nothing about tolerances at the time and did not take those into account during my designs, I only had to remove one screw and not fully tighten another for the case to be perfectly aligned. Both problematic screws where on the front panel \u201cS\u201d mounting bracket, which I knew would be a very tight fit without using tolerances. Now that you have all the pieces at hand, let\u2019s play some Lego\u00ae \ud83d\ude04! First, screw the motherboard to the Rack chassis, then the daughterboard to the mounting bracket. Do not forget to add rear screws to the stacked jack headers to relieve the pressure on the solder joints while inserting or removing jacks. Note Please note that I decided to remove the bottom middle screw of the daughter board to avoid inducing tension to the PCB. You can now place the mounting bracket on to the rack chassis, and connect the ribbon cable between the two PCBs. Then, snap the bezel into the front panel. This should be a precise fit and should not require any rework and/or glue to make it stick. Screw the front panel and the cover together. Finally, screw together the two subassemblies. You\u2019re done! Note On my unit, the top right screw of the mounting bracket is not fully tightened. When it is, some of the switches do not properly work. It comes from the fact that the rack was designed without any tolerances consideration. Knowing that, I consider it a miracle that I only have 2 minor flaws on the final product. That underlines once more Protocase\u2019s wonderful work.","title":"Assembly"},{"location":"firmware/","text":"Firmware \u00b6 The project was developed using Arduino 1.6.x, and works with the latest version of Arduino and librairies. The traditional Arduino .ino is not an option to be followed for any project with some respect for clean code. As such, the projects is split across several files and ditching the Arduino IDE for more advanced one (VSCode, Visual Micro, \u2026) is strongly recommended. Compiling \u00b6 Install the required libraries through Arduino\u2019s Library Manager or with the following script. You can omit the version but just in case, those were the ones used to build the firmware. arduino --install-library \"AS1115:1.1.1\" arduino --install-library \"E24:1.1.0\" arduino --install-library \"MCP23017:1.0.1\" arduino --install-library \"MIDI Library:4.3.1\" arduino --install-library \"MIDIUSB:1.0.3\" Build the sketch with your IDE or by running arduino --verify --board arduino:avr:micro src/MLS800.ino . Interrupts \u00b6 All of the ATmega32U4 external interrupts are used Interrupt Use INT0 , INT1 MIDI port INT2 , INT3 USB Serial port INT6 User input 1 Main loop \u00b6 To offer the best response time possible to MIDI commands while playing, the main loop is kept simple and as fast as possible by not using any delays. Every delay needed - for instance for the user interface to blink - are run conditionally and use millis() . Menu \u00b6 The MLS800 menu is kinda designed around the action design pattern . Each menu entry describes its content, its relation and how to respond to user inputs. For instance, pressing the Edit key in some cases saves the changes and calls for a back action. That pattern keeps things tidy, easy to read and change while being memory efficient. It also nicely split the menu features implementation from its UI. EEPROM memory structure \u00b6 The stock schematics use a 24LC256 which provides 256Kb of EEPROM memory. Currently, only the first half of that memory is used, and badly aligned. In reality, only a byte is needed to store a preset, but the original idea was to implement more complex patches that could respond to Control Change MIDI messages on top of changing patches with Program Change . That idea was never implemented, and 128 presets being more than enough for my use, the memory layout stayed that way. Address Name Size (bytes) Notes 0x00 Main configuration 17 seed 5 Used to detect invalid and/or blank configuration version 7 Version string rxChannel 1 MIDI Rx channel [ 0 - 16 ], 0 for Omni Mode txChannel 1 MIDI Tx channel [ 0 - 16 ], unused patchNumber 1 Active path number currentState 1 Current loops state displayDim 1 Display intensity [ 0 - 15 ] 0x11 Reserved 47 0x40 Patch 0 129 Yep, this is bad design data 1 Patch 0 loops state cc 0 1 Control Change 0 sub state ... cc 127 1 Control Change 127 sub state ... 0x403F Patch 128 129 Last patch 2 Loops state \u00b6 A loop state is mapped to a single byte, where each bit corresponds to the same loop number state (bit 0 to loop 0 etc). Sending the current state to reflect on the display is straightforward, but reflecting that state on audio loops is another story. On the MCP23017, port A bits 0 to 7 turn loops 8 to 1 ON, while bits 0 to 7 turn loops 1 to 8 OFF on port B. Bits manipulation are fast and easy so priority has been given to PCB layout to keep traces parallel and avoid routing the audio signal from one side of the PCB to another. At the time of conception, INT6 was unsupported by the Arduino framework. That explains code setting it up. \u21a9 But still plenty of room left \u21a9","title":"Firmware"},{"location":"firmware/#firmware","text":"The project was developed using Arduino 1.6.x, and works with the latest version of Arduino and librairies. The traditional Arduino .ino is not an option to be followed for any project with some respect for clean code. As such, the projects is split across several files and ditching the Arduino IDE for more advanced one (VSCode, Visual Micro, \u2026) is strongly recommended.","title":"Firmware"},{"location":"firmware/#compiling","text":"Install the required libraries through Arduino\u2019s Library Manager or with the following script. You can omit the version but just in case, those were the ones used to build the firmware. arduino --install-library \"AS1115:1.1.1\" arduino --install-library \"E24:1.1.0\" arduino --install-library \"MCP23017:1.0.1\" arduino --install-library \"MIDI Library:4.3.1\" arduino --install-library \"MIDIUSB:1.0.3\" Build the sketch with your IDE or by running arduino --verify --board arduino:avr:micro src/MLS800.ino .","title":"Compiling"},{"location":"firmware/#interrupts","text":"All of the ATmega32U4 external interrupts are used Interrupt Use INT0 , INT1 MIDI port INT2 , INT3 USB Serial port INT6 User input 1","title":"Interrupts"},{"location":"firmware/#main-loop","text":"To offer the best response time possible to MIDI commands while playing, the main loop is kept simple and as fast as possible by not using any delays. Every delay needed - for instance for the user interface to blink - are run conditionally and use millis() .","title":"Main loop"},{"location":"firmware/#menu","text":"The MLS800 menu is kinda designed around the action design pattern . Each menu entry describes its content, its relation and how to respond to user inputs. For instance, pressing the Edit key in some cases saves the changes and calls for a back action. That pattern keeps things tidy, easy to read and change while being memory efficient. It also nicely split the menu features implementation from its UI.","title":"Menu"},{"location":"firmware/#eeprom-memory-structure","text":"The stock schematics use a 24LC256 which provides 256Kb of EEPROM memory. Currently, only the first half of that memory is used, and badly aligned. In reality, only a byte is needed to store a preset, but the original idea was to implement more complex patches that could respond to Control Change MIDI messages on top of changing patches with Program Change . That idea was never implemented, and 128 presets being more than enough for my use, the memory layout stayed that way. Address Name Size (bytes) Notes 0x00 Main configuration 17 seed 5 Used to detect invalid and/or blank configuration version 7 Version string rxChannel 1 MIDI Rx channel [ 0 - 16 ], 0 for Omni Mode txChannel 1 MIDI Tx channel [ 0 - 16 ], unused patchNumber 1 Active path number currentState 1 Current loops state displayDim 1 Display intensity [ 0 - 15 ] 0x11 Reserved 47 0x40 Patch 0 129 Yep, this is bad design data 1 Patch 0 loops state cc 0 1 Control Change 0 sub state ... cc 127 1 Control Change 127 sub state ... 0x403F Patch 128 129 Last patch 2","title":"EEPROM memory structure"},{"location":"firmware/#loops-state","text":"A loop state is mapped to a single byte, where each bit corresponds to the same loop number state (bit 0 to loop 0 etc). Sending the current state to reflect on the display is straightforward, but reflecting that state on audio loops is another story. On the MCP23017, port A bits 0 to 7 turn loops 8 to 1 ON, while bits 0 to 7 turn loops 1 to 8 OFF on port B. Bits manipulation are fast and easy so priority has been given to PCB layout to keep traces parallel and avoid routing the audio signal from one side of the PCB to another. At the time of conception, INT6 was unsupported by the Arduino framework. That explains code setting it up. \u21a9 But still plenty of room left \u21a9","title":"Loops state"},{"location":"gallery/","text":"Gallery \u00b6","title":"Gallery"},{"location":"gallery/#gallery","text":"","title":"Gallery"},{"location":"hardware/","text":"Hardware \u00b6 The MLS800 is built around two surface mounted PCBs: a motherboard that holds the main unit and rear connectors, and a daughter board that contains elements the user interacts with during use. Those two boards fit in a custom designed hot rolled steel enclosure with self-clinching fasteners and digital printing for a nice, professional-like finish. The motherboard \u00b6 The MLS800 is based on the Arduino Micro design. As such, it is powered by an ATmega32U4 . The ATmega32U4 does not need an additional IC to interface with a USB port and provides 2 hardware serial ports out of the box. The MIDI protocol being a serial communication protocol, this choice made perfect sense. Connected to that processor are several ICs. A MCP23017 port expander drives two ULN2803ADW NPN arrays. Each pair of NPN transistor drive one V23079E1201B301 bistable relays. This design allows to keeps things simple on every level. PCB traces are kept parallel and changes sides as few times as possible, and port A of the MCP23017 is used to turn loops ON while port B turn them off. Bistable relays allows reducing power consumption, as power is only needed while changing their state. Finally, an 24LC256 EEPROM is used for preset storage. The power is supplied by 2 LM340MP-5.0/NOPB each capable of delivering 1.5A@5VDC. ATmega32U4 main processor MCP23017 port expander 24LC256 256Kb EEPROM 2 ULN2803ADW NPN arrays 2 LM340 regulators The input board \u00b6 The input board is simply a daughter board that connects directly to the motherboard. It contains a LTC-5723HR 4 digits 7 segments display and 10 high quality illuminated Apem MEC switches switches (5GSH93582 combined with 1ES096 caps). The display and 8 of the switches are controlled by an AS1115-BSST , while the two remaining switches are controlled directly by the main processor. The AS1115 being capable of driving up to eight 7 segments, a neat trick is to consider the 8 LEDs of the loop switches as a fifth digit. Saving ATmega32U4 pins, power, and reducing component count at the same time! The enclosure \u00b6 The enclosure is made out of 4 black painted and bent hot rolled steel sheets and assembled with self-clinching fasteners. It helps to keep the out surface smooth and gives the overall a professional-like finish. A laser cut acrylic bezel and the digitally printed front panel helps push that feeling even further. Another choice I\u2019m really happy with is using NSJ8HC stacked jacks header. Even if they are expensive, they reduce the PCB length, and also provide a tightening screw which helps relieve the pressure against the motherboard when inserting jacks. I\u2019ve sent the case files over to a Canadian company, Protocase , and - oh boy - they\u2019ve done an outstanding job building it! The good thing is they\u2019re able to produce parts from start to finish, including printing them. The enclosure you see on the pictures is the one I\u2019ve got straight out of the mail, including the screws! When one passes by my gear and ask about it, he does not notice that one of the racks is entirely \u201chome\u201d made. I really highly recommend Protocase if you ever need this kind of service.","title":"Hardware"},{"location":"hardware/#hardware","text":"The MLS800 is built around two surface mounted PCBs: a motherboard that holds the main unit and rear connectors, and a daughter board that contains elements the user interacts with during use. Those two boards fit in a custom designed hot rolled steel enclosure with self-clinching fasteners and digital printing for a nice, professional-like finish.","title":"Hardware"},{"location":"hardware/#the-motherboard","text":"The MLS800 is based on the Arduino Micro design. As such, it is powered by an ATmega32U4 . The ATmega32U4 does not need an additional IC to interface with a USB port and provides 2 hardware serial ports out of the box. The MIDI protocol being a serial communication protocol, this choice made perfect sense. Connected to that processor are several ICs. A MCP23017 port expander drives two ULN2803ADW NPN arrays. Each pair of NPN transistor drive one V23079E1201B301 bistable relays. This design allows to keeps things simple on every level. PCB traces are kept parallel and changes sides as few times as possible, and port A of the MCP23017 is used to turn loops ON while port B turn them off. Bistable relays allows reducing power consumption, as power is only needed while changing their state. Finally, an 24LC256 EEPROM is used for preset storage. The power is supplied by 2 LM340MP-5.0/NOPB each capable of delivering 1.5A@5VDC. ATmega32U4 main processor MCP23017 port expander 24LC256 256Kb EEPROM 2 ULN2803ADW NPN arrays 2 LM340 regulators","title":"The motherboard"},{"location":"hardware/#the-input-board","text":"The input board is simply a daughter board that connects directly to the motherboard. It contains a LTC-5723HR 4 digits 7 segments display and 10 high quality illuminated Apem MEC switches switches (5GSH93582 combined with 1ES096 caps). The display and 8 of the switches are controlled by an AS1115-BSST , while the two remaining switches are controlled directly by the main processor. The AS1115 being capable of driving up to eight 7 segments, a neat trick is to consider the 8 LEDs of the loop switches as a fifth digit. Saving ATmega32U4 pins, power, and reducing component count at the same time!","title":"The input board"},{"location":"hardware/#the-enclosure","text":"The enclosure is made out of 4 black painted and bent hot rolled steel sheets and assembled with self-clinching fasteners. It helps to keep the out surface smooth and gives the overall a professional-like finish. A laser cut acrylic bezel and the digitally printed front panel helps push that feeling even further. Another choice I\u2019m really happy with is using NSJ8HC stacked jacks header. Even if they are expensive, they reduce the PCB length, and also provide a tightening screw which helps relieve the pressure against the motherboard when inserting jacks. I\u2019ve sent the case files over to a Canadian company, Protocase , and - oh boy - they\u2019ve done an outstanding job building it! The good thing is they\u2019re able to produce parts from start to finish, including printing them. The enclosure you see on the pictures is the one I\u2019ve got straight out of the mail, including the screws! When one passes by my gear and ask about it, he does not notice that one of the racks is entirely \u201chome\u201d made. I really highly recommend Protocase if you ever need this kind of service.","title":"The enclosure"},{"location":"history/","text":"Project history \u00b6","title":"Project history"},{"location":"history/#project-history","text":"","title":"Project history"},{"location":"manual/","text":"User Manual \u00b6 Presentation \u00b6 The MLS800 is a very easy to use MIDI controlled Loop Switcher with 8 independent audio loops. It adapts itself to your gear and setup, not the other way around! 8 independent audio loops 128 presets Active preset is remotely controlled through Program Change MIDI messages Easy to read through a 4 digits 7 segments display and 9 illuminated switches Open source Great, now what? The whole idea of a loop switcher is to enable or disable audio loops. Each loop consists of a send and a return signal, with something processing the signal in between. in=>start: Previous loop out=>end: Next loop lc=>condition: Loop active ? l=>inputoutput: External unit lr=>inputoutput: Loop return in->lc(yes,bottom)->l lc(no)->lr l(right)->lr lr(right)->out By chaining several loops, the MLS800 acts as a router that directs your audio signal to up to 8 external processing units. Leaving you with 2 8 possibilities to route your signal! Know your gear \u00b6 Front panel \u00b6 circle#bubble-back, .annotated-graphic marker { fill: #EF5350; } .annotated-graphic polyline, .annotated-graphic rect { fill: none; stroke: #EF5350; stroke-width: 4; } .annotated-graphic polyline { marker-end: url(#arrow); } .annotated-graphic rect { rx: 15; ry: 15; } .annotated-graphic text { stroke: white; fill: white; text-anchor: middle; dominant-baseline: central; font-size: 1.5em; } MLS800 front 1 2 3 4 5 6 7 Menu / Power indicator Edit / Mode indicator Main display Editing indicator Loop 1 key / Up Loop 2 key / Down Loop 3 to 8 keys Back panel \u00b6 MLS800 back 1 2 3 4 5 9 7 8 6 Power supply input: 2mm ID, 5.5mm OD, positively centered. 9 to 12 VDC @ 1A minimum. Basically, any supply fitting an Arduino Uno will do. Reset switch USB port. Provides a Serial port and 1x MIDI In, 1x MIDI out ports. MIDI Input MIDI Thru Main audio input Loops 1 to 8 send signal Loops 1 to 8 return signal Main audio output Danger Always use the recommended power supply with the MLS800. Do not exceed the maximum recommended voltage of 12VDC. The USB port does not provide power to the unit. First use \u00b6 On power on, the MLS800 applies the last active preset and displays the firmware version for a brief moment. The unit then enters into the Playing mode. Modes \u00b6 The MLS800 acts around 3 modes : playing=>operation: Playing learning=>operation: Learning editing=>operation: Editing playing(right)->learning(right)->editing Playing : Normal use. Display the active preset. Learning : Waiting for a Program Change MIDI command. The main display and Edit are blinking. Editing : Editing a preset. The main display editing indicator and Edit are on. You pass from one mode to another by pressing Edit . Playing \u00b6 The MLS800 displays the active preset and listens for an incoming MIDI Program Change message. If received, the corresponding preset number will be applied. Note You can manually change the active preset using Up or Down . Learning \u00b6 The MLS800 main display and Edit are blinking, while waiting for an incoming Program Change message. Upon receiving one, the current preset state will remain unchanged, and the unit will switch to Editing mode for the requested preset number. Copying a preset You can use the fact that the current state will remain unchanged to copy a preset to a new location. Editing the current preset Simply press Edit a second time while in Learning mode to edit the current preset. Editing \u00b6 The editing indicator and Edit are on. Use keys 1 to 8 to change to the corresponding loop state. Validate your changes by pressing Edit , or cancel them by pressing Menu . Configuration \u00b6 You can enter the configuration menu by pressing Menu while in Playing mode. Button Navigation Edition Menu Exit (sub-)menu Cancel edit Edit Enter (sub-)menu / Edit value Save value \ud83d\udd3c ( Up ) Navigate up Increase value \ud83d\udd3d ( Down ) Navigate down Decrease value Editing a value works like in Editing mode. The editing indicator is on, Edit will save the value while Menu will cancel the changes. Menu Description menu Main menu. Press Menu to return to Playing mode. midi Configures MIDI. \u2192 r Configures MIDI Rx channel from 0 to 16 . 0 listen to all channels (Omni mode). dim Configures the main display intensity, from 0 to 15 . clr Factory reset. \u2192 yes Proceeds with factory reset. After a few seconds, Clear done ( clrd ) is displayed. \u2192 no Cancels the factory reset. Warning Factory reset will erase the MLS800 configuration and all presets data ! Firmware update \u00b6 Being open source, there are several ways you can get this done. Simply pick the one that suits you! Flashing the firmware, the simple way Download the latest release and uncompress its content. Connect the MLS800 to your computer using a USB-B cable. Run update.bat on Windows, update.sh on Linux I\u2019m a command-line guy ! Download the latest release and uncompress its content. Connect the MLS800 to your computer using a USB-B cable. Run avrdude -C avrdude.conf -c arduino -p m32u4 -b 57600 -D -P COM4 -U flash:w:MLS800.hex:i -vv , replacing COM4 by the actual MLS800 COM port on your machine I\u2019m a developer ! Clone blemasle/mls800-firmware Compiling with the IDE of your choice (but seriously, ditch that Arduino IDE) using the Arduino Micro board Upload with your IDE or the command line above","title":"User Manual"},{"location":"manual/#user-manual","text":"","title":"User Manual"},{"location":"manual/#presentation","text":"The MLS800 is a very easy to use MIDI controlled Loop Switcher with 8 independent audio loops. It adapts itself to your gear and setup, not the other way around! 8 independent audio loops 128 presets Active preset is remotely controlled through Program Change MIDI messages Easy to read through a 4 digits 7 segments display and 9 illuminated switches Open source Great, now what? The whole idea of a loop switcher is to enable or disable audio loops. Each loop consists of a send and a return signal, with something processing the signal in between. in=>start: Previous loop out=>end: Next loop lc=>condition: Loop active ? l=>inputoutput: External unit lr=>inputoutput: Loop return in->lc(yes,bottom)->l lc(no)->lr l(right)->lr lr(right)->out By chaining several loops, the MLS800 acts as a router that directs your audio signal to up to 8 external processing units. Leaving you with 2 8 possibilities to route your signal!","title":"Presentation"},{"location":"manual/#know-your-gear","text":"","title":"Know your gear"},{"location":"manual/#front-panel","text":"circle#bubble-back, .annotated-graphic marker { fill: #EF5350; } .annotated-graphic polyline, .annotated-graphic rect { fill: none; stroke: #EF5350; stroke-width: 4; } .annotated-graphic polyline { marker-end: url(#arrow); } .annotated-graphic rect { rx: 15; ry: 15; } .annotated-graphic text { stroke: white; fill: white; text-anchor: middle; dominant-baseline: central; font-size: 1.5em; } MLS800 front 1 2 3 4 5 6 7 Menu / Power indicator Edit / Mode indicator Main display Editing indicator Loop 1 key / Up Loop 2 key / Down Loop 3 to 8 keys","title":"Front panel"},{"location":"manual/#back-panel","text":"MLS800 back 1 2 3 4 5 9 7 8 6 Power supply input: 2mm ID, 5.5mm OD, positively centered. 9 to 12 VDC @ 1A minimum. Basically, any supply fitting an Arduino Uno will do. Reset switch USB port. Provides a Serial port and 1x MIDI In, 1x MIDI out ports. MIDI Input MIDI Thru Main audio input Loops 1 to 8 send signal Loops 1 to 8 return signal Main audio output Danger Always use the recommended power supply with the MLS800. Do not exceed the maximum recommended voltage of 12VDC. The USB port does not provide power to the unit.","title":"Back panel"},{"location":"manual/#first-use","text":"On power on, the MLS800 applies the last active preset and displays the firmware version for a brief moment. The unit then enters into the Playing mode.","title":"First use"},{"location":"manual/#modes","text":"The MLS800 acts around 3 modes : playing=>operation: Playing learning=>operation: Learning editing=>operation: Editing playing(right)->learning(right)->editing Playing : Normal use. Display the active preset. Learning : Waiting for a Program Change MIDI command. The main display and Edit are blinking. Editing : Editing a preset. The main display editing indicator and Edit are on. You pass from one mode to another by pressing Edit .","title":"Modes"},{"location":"manual/#playing","text":"The MLS800 displays the active preset and listens for an incoming MIDI Program Change message. If received, the corresponding preset number will be applied. Note You can manually change the active preset using Up or Down .","title":"Playing"},{"location":"manual/#learning","text":"The MLS800 main display and Edit are blinking, while waiting for an incoming Program Change message. Upon receiving one, the current preset state will remain unchanged, and the unit will switch to Editing mode for the requested preset number. Copying a preset You can use the fact that the current state will remain unchanged to copy a preset to a new location. Editing the current preset Simply press Edit a second time while in Learning mode to edit the current preset.","title":"Learning"},{"location":"manual/#editing","text":"The editing indicator and Edit are on. Use keys 1 to 8 to change to the corresponding loop state. Validate your changes by pressing Edit , or cancel them by pressing Menu .","title":"Editing"},{"location":"manual/#configuration","text":"You can enter the configuration menu by pressing Menu while in Playing mode. Button Navigation Edition Menu Exit (sub-)menu Cancel edit Edit Enter (sub-)menu / Edit value Save value \ud83d\udd3c ( Up ) Navigate up Increase value \ud83d\udd3d ( Down ) Navigate down Decrease value Editing a value works like in Editing mode. The editing indicator is on, Edit will save the value while Menu will cancel the changes. Menu Description menu Main menu. Press Menu to return to Playing mode. midi Configures MIDI. \u2192 r Configures MIDI Rx channel from 0 to 16 . 0 listen to all channels (Omni mode). dim Configures the main display intensity, from 0 to 15 . clr Factory reset. \u2192 yes Proceeds with factory reset. After a few seconds, Clear done ( clrd ) is displayed. \u2192 no Cancels the factory reset. Warning Factory reset will erase the MLS800 configuration and all presets data !","title":"Configuration"},{"location":"manual/#firmware-update","text":"Being open source, there are several ways you can get this done. Simply pick the one that suits you! Flashing the firmware, the simple way Download the latest release and uncompress its content. Connect the MLS800 to your computer using a USB-B cable. Run update.bat on Windows, update.sh on Linux I\u2019m a command-line guy ! Download the latest release and uncompress its content. Connect the MLS800 to your computer using a USB-B cable. Run avrdude -C avrdude.conf -c arduino -p m32u4 -b 57600 -D -P COM4 -U flash:w:MLS800.hex:i -vv , replacing COM4 by the actual MLS800 COM port on your machine I\u2019m a developer ! Clone blemasle/mls800-firmware Compiling with the IDE of your choice (but seriously, ditch that Arduino IDE) using the Arduino Micro board Upload with your IDE or the command line above","title":"Firmware update"},{"location":"_partials/disclaimer/","text":"Disclaimer The present project was a personal study case to see I close I could come to a \u201cprofessional\u201d product. I knew almost nothing at the time and had to learn everything. As a consequence, and while I did my best, the finished result is not flawless.","title":"Disclaimer"},{"location":"_partials/features/","text":"8 independent audio loops 128 presets Active preset is remotely controlled through Program Change MIDI messages Easy to read through a 4 digits 7 segments display and 9 illuminated switches Open source","title":"Features"},{"location":"_partials/repositories/","text":"The project is built around three repositories : blemasle/mls800-pcb : Motherboard and daughterboard PCBs blemasle/mls800-firmware : Firmware that needs to be loaded onto the motherboard blemasle/mls800-enclosure : CAD files needed to produce the enclosure","title":"Repositories"},{"location":"_partials/uml/","text":"","title":"Uml"}]}